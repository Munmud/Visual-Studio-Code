{
  "graph moves": {
    "prefix": "graph moves",
    "body": [
      "/*----------------------Graph Moves----------------*/\r",
      "// const int fx[]={+1,-1,+0,+0};\r",
      "// const int fy[]={+0,+0,+1,-1};\r",
      "// const int fx[]={+0,+0,+1,-1,-1,+1,-1,+1};   // Kings Move\r",
      "// const int fy[]={-1,+1,+0,+0,+1,+1,-1,-1};  // Kings Move\r",
      "// const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move\r",
      "// const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move\r",
      "/*------------------------------------------------*/"
    ],
    "description": "graph moves in two array"
  },
  "bitmask": {
    "prefix": "bitmask",
    "body": [
      "/*-----------------------Bitmask------------------*/\r",
      "int Set(int N,int pos){return N=N | (1<<pos);}\r",
      "int reset(int N,int pos){return N= N & ~(1<<pos);}\r",
      "bool check(int N,int pos){return (bool)(N & (1<<pos));}\r",
      "/*------------------------------------------------*/"
    ],
    "description": "bitmask set, reset and check"
  },
  "ncr": {
    "prefix": "ncr",
    "body": [
      "// --------- NCR Start here ------------\r",
      "template<typename T>\r",
      "T nCr(T n, T r) {\r",
      "    if(r > n - r) r = n - r;\r",
      "    int  ans = 1,i;\r",
      "    for(i = 1; i <= r; i++) {\r",
      "        ans *= n - r + i;\r",
      "        ans /= i;\r",
      "    }\r",
      "return ans;\r",
      "}\r",
      "// ------------------End here -----------------"
    ],
    "description": "ncr"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "// --------------  Start Here -------------\r",
      "vector <int> primeNumber ;\r",
      "void sieve(int n)\r",
      "{\r",
      "    bool primeMark[1000002] ;\r",
      "    memset(primeMark , 0 , sizeof(primeMark) ) ;\r",
      "    int i , j , limit = sqrt(n*1.) +2 ;\r",
      "    //primeMark[1] = 1 ;\r",
      "    //for (i = 4 ; i<=n ; i+=2) primeMark[i] = 1 ;\r",
      "\r",
      "    primeNumber.emplace_back(2) ;\r",
      "    for (i = 3 ; i<=n ; i+=2)\r",
      "    {\r",
      "        if (primeMark[i] == 1) continue ;\r",
      "        primeNumber.emplace_back(i) ;\r",
      "        if (i<=limit){\r",
      "            for (j = i*i ; j<=n ; j+=i*2)\r",
      "                primeMark[j] = 1 ;\r",
      "        }\r",
      "    }\r",
      "}\r",
      "// ----------- End here ----------------"
    ],
    "description": "prive number generate in a vector"
  },
  "bigmod": {
    "prefix": "bigmod",
    "body": [
      "//----------- Mod inverse/Big mod Start here ----------\r",
      "template <class T> inline T bigmod(T p,T e,T M){\r",
      "    ll ret = 1;\r",
      "    for(; e > 0; e >>= 1){\r",
      "        if(e & 1) ret = (ret * p) % M;\r",
      "        p = (p * p) % M;\r",
      "    } return (T)ret;\r",
      "}\r",
      "template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\r",
      "//----------- ------------------------------------ ----------"
    ],
    "description": "mod inverse or big mod"
  },
  "policy based data structure": {
    "prefix": "pbds",
    "body": [
      "/*----------------------Policy Based Data Structures in g++----------------*/",
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "#include <ext/pb_ds/detail/standard_policies.hpp>",
      "using namespace __gnu_pbds;",
      "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
      "",
      "// less<int>, greater<int>, less_equal<int>",
      "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key",
      "",
      "// pbds A;// declaration",
      "// // Inserting elements - 1st query",
      "// A.insert(2); // ordered set only contains unique values",
      "",
      "// // A contains",
      "// cout << \"A = \";",
      "// for (auto i : A)",
      "//     cout << i << \" \";",
      "// cout << endl;",
      "// cout << endl;",
      "",
      "// // finding kth element - 4th query",
      "// cout << \"0th element: \" << *A.find_by_order(0) << endl;",
      "// // finding number of elements smaller than X - 3rd query",
      "// cout << \"No. of elems smaller than 6: \" << A.order_of_key(6) << endl;",
      "// // lower bound -> Lower Bound of X = first element >= X in the set",
      "// cout << \"Lower Bound of 6: \" << *A.lower_bound(6) << endl;",
      "// // Upper bound -> Upper Bound of X = first element > X in the set",
      "// cout << \"Upper Bound of 6: \" << *A.upper_bound(6) << endl;",
      "// // // Remove elements - 2nd query",
      "// A.erase(1);",
      "// A.erase(11); // element that is not present is not affected",
      "",
      "/*---------------------------------- x ------------------------------------*/"
    ],
    "description": "policy based data structure"
  },
  "usaco template": {
    "prefix": "usaco template",
    "body": [
      "/*\r",
      "ID: moontas2\r",
      "PROG: gift1\r",
      "LANG: C++                 \r",
      "*/\r",
      "#include <fstream>\r",
      "#include <bits/stdc++.h>\r",
      "\r",
      "#define setinf(ar)              memset(ar,126,sizeof ar)\r",
      "#define MEM(a, b)               memset ( a, (b), sizeof(a) )\r",
      "#define MAX(a, b)               ((a) > (b) ? (a) : (b))\r",
      "#define MIN(a, b)               ((a) < (b) ? (a) : (b))\r",
      "#define ABS(X)                  ( (X) > 0 ? (X) : ( -(X) ) )\r",
      "#define S(X)                    ( (X) * (X) )\r",
      "#define SZ(V)                   (int )V.size()\r",
      "#define FORN(i, n)              for(int i = 0; i < n; i++)\r",
      "#define FORAB(i, a, b)          for(int i = a; i <= b; i++)\r",
      "#define ALL(V)                  V.begin(), V.end()\r",
      "#define ALLR(V)                 V.rbegin(), V.rend()\r",
      "#define IN(A, B, C)             ((B) <= (A) && (A) <= (C))\r",
      "#define AIN(A, B, C)            assert(IN(A, B, C))\r",
      "\r",
      "#define wa2(x , y)              cout << (#x) << \" \" << (#y)<< \" is \" << (x) << \" \" << (y)<< endl\r",
      "#define wa(x)                   cout << (#x) << \" is \" << (x) << endl\r",
      "\r",
      "#define ll                      long long int\r",
      "#define xx                      first\r",
      "#define yy                      second\r",
      "#define pb                   push_back\r",
      "#define PI                      acos(-1.0)\r",
      "\r",
      "#define PII                     pair<int, int>\r",
      "#define PLL                     pair<long long int, long long int>\r",
      "#define VI                      vector <int>\r",
      "#define VL                      vector <long long int>\r",
      "\r",
      "#define BOUNDARY(i, j, r , c)   ((i >= 0 && i < r) && (j >= 0 && j < c))\r",
      "#define max3(x, y, z)           MAX(MAX(x, y), MAX(y, z))\r",
      "\r",
      "#define front_zero(n)           __builtin_clzll(n)\r",
      "#define back_zero(n)            __builtin_ctzll(n)\r",
      "#define total_one(n)            __builtin_popcountll(n)\r",
      "\r",
      "\r",
      "using namespace std;\r",
      "\r",
      "\r",
      "template < typename F, typename S >\r",
      "ostream& operator << ( ostream& os, const pair< F, S > & p ) {\r",
      "    return os << \"(\" << p.first << \", \" << p.second << \")\";\r",
      "}\r",
      "template <class T>\r",
      "ostream & operator << (ostream & os, vector <T> const& x) {\r",
      "    os << \"{ \";\r",
      "    for(auto& y : x) os << y << \" \";\r",
      "    return os << \"}\";\r",
      "}\r",
      "template <class T>\r",
      "ostream & operator << (ostream & os, set <T> const& x) {\r",
      "    os << \"{ \";\r",
      "    for(auto& y : x) os << y << \" \";\r",
      "    return os << \"}\";\r",
      "}\r",
      "template < typename T >\r",
      "ostream &operator << ( ostream & os, const multiset< T > &v ) {\r",
      "    os << \"[\";\r",
      "    typename multiset< T > :: const_iterator it;\r",
      "    for ( it = v.begin(); it != v.end(); it++ ) {\r",
      "        if( it != v.begin() ) os << \", \";\r",
      "        os << *it;\r",
      "    }\r",
      "    return os << \"]\";\r",
      "}\r",
      "template < typename F, typename S >\r",
      "ostream &operator << ( ostream & os, const map< F, S > &v ) {\r",
      "    os << \"[\";\r",
      "    typename map< F , S >::const_iterator it;\r",
      "    for( it = v.begin(); it != v.end(); it++ ) {\r",
      "        if( it != v.begin() ) os << \", \";\r",
      "        os << it -> first << \" = \" << it -> second ;\r",
      "    }\r",
      "    return os << \"]\";\r",
      "}\r",
      "/*---------------------------------- x ------------------------------------*/\r",
      "\r",
      "\r",
      "ofstream fout (\"gift1.out\");\r",
      "ifstream fin (\"gift1.in\");\r",
      "\r",
      "#define SIZE                (int)5005\r",
      "#define MOD                 1000000007\r",
      "\r",
      "void _main_main()\r",
      "{\r",
      "    \r",
      "\r",
      "}\r",
      "\r",
      "int main ()\r",
      "{\r",
      "    ios::sync_with_stdio(0);\r",
      "    cin.tie(0);\r",
      "    cout.tie(0);\r",
      "\r",
      "    int testCase = 1 ;//cin >> testCase ;\r",
      "    for (int i = 0; i < testCase; i++){\r",
      "        \r",
      "        _main_main() ;\r",
      "    }\r",
      "        \r",
      "}"
    ],
    "description": "usaco template"
  },
  "trie tree": {
    "prefix": "trie tree",
    "body": [
      "\r",
      "/* ------------- trie tree start here-------------------*/\r",
      "\r",
      "// initiall 'a-z' is considered \r",
      "const int ALPHABET_SIZE = 26; \r",
      "\r",
      "struct node {\r",
      "    bool endmark;\r",
      "    node* next[ALPHABET_SIZE + 1];\r",
      "    node()\r",
      "    {\r",
      "        endmark = false;\r",
      "        for (int i = 0; i < ALPHABET_SIZE; i++)\r",
      "            next[i] = NULL;\r",
      "    }\r",
      "} * root;\r",
      "\r",
      "void inst(string str)\r",
      "{\r",
      "\tint len = str.size() ;\r",
      "    node* curr = root;\r",
      "    for (int i = 0; i < len; i++) {\r",
      "        int id = str[i] - 'a';\r",
      "        if (curr->next[id] == NULL)\r",
      "            curr->next[id] = new node();\r",
      "        curr = curr->next[id];\r",
      "    }\r",
      "    curr->endmark = 1;\r",
      "}\r",
      "\r",
      "bool srch(string str)\r",
      "{\r",
      "\tint len = str.size() ;\r",
      "    node* curr = root;\r",
      "    for (int i = 0; i < len; i++) {\r",
      "        int id = str[i] - 'a';\r",
      "        if (curr->next[id] == NULL)\r",
      "            return false;\r",
      "        curr = curr->next[id];\r",
      "    }\r",
      "    return curr->endmark;\r",
      "}\r",
      "\r",
      "void del(node* cur)\r",
      "{\r",
      "    for (int i = 0; i < ALPHABET_SIZE; i++)\r",
      "        if (cur->next[i])\r",
      "            del(cur->next[i]);\r",
      "    delete (cur);\r",
      "}\r",
      "\r",
      "/* ------------- trie tree end here-------------------*/\r",
      ""
    ],
    "description": "trie tree insert search and delete"
  },
  "decimal to binary": {
    "prefix": "decimal to binary",
    "body": [
      "/*----------- decimal to binary start here --------*/\r",
      "string decToBinary(int n) \r",
      "{ \r",
      "    string s ;\r",
      "    // Size of an integer is assumed to be 32 bits \r",
      "    for (int i = 31; i >= 0; i--) {  \r",
      "        if ( (1ll<<i) & n) \r",
      "            s+= \"1\"; \r",
      "        else\r",
      "            s+= \"0\"; \r",
      "    } \r",
      "    return s ;\r",
      "} \r",
      "/*----------- decimal to binary end here --------*/"
    ],
    "description": "decimal to binary"
  },
  "floyd warshall": {
    "prefix": "floyd warshall",
    "body": [
      "\r",
      "// defining the number of vertices\r",
      "#define nV 4\r",
      "\r",
      "// Implementing floyd warshall algorithm\r",
      "void floydWarshall(int matrix[][nV]) {\r",
      "\r",
      "\r",
      "  // Adding vertices individually\r",
      "  for (int k = 0; k < nV; k++) {\r",
      "    for (int i = 0; i < nV; i++) {\r",
      "      for (int j = 0; j < nV; j++) {\r",
      "        if (matrix[i][k] + matrix[k][j] < matrix[i][j])\r",
      "          matrix[i][j] = matrix[i][k] + matrix[k][j];\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "}"
    ],
    "description": "floyd warshall algorithm"
  },
  "mst kruskal": {
    "prefix": "mst kruskal",
    "body": [
      "\r",
      "struct edge\r",
      "{\r",
      "    int u , v , w ;\r",
      "    edge(int _u , int _v , int _w)\r",
      "    {\r",
      "        u = _u ;\r",
      "        v = _v ;\r",
      "        w = _w ;\r",
      "    }\r",
      "    bool operator < (const edge &p) const{\r",
      "        return w < p.w ;\r",
      "    }\r",
      "};\r",
      "\r",
      "int parent[10000] ;\r",
      "vector <edge> e ;\r",
      "int find_parent(int r)\r",
      "{\r",
      "    return (parent[r] == r ? r : find_parent(parent[r])) ;\r",
      "}\r",
      "\r",
      "int mst(int n)\r",
      "{\r",
      "    sort(e.begin() , e.end()) ;\r",
      "    for(int i = 1 ; i<=n ; i++) parent[i] = i ;\r",
      "\r",
      "    int cnt = 0 , s = 0 ;\r",
      "    for (int i = 0 ; i<e.size() ; i++)\r",
      "    {\r",
      "        int u = find_parent(e[i].u) ;\r",
      "        int v = find_parent(e[i].v) ;\r",
      "\r",
      "        if (u!=v)\r",
      "        {\r",
      "            parent[u] = v ;\r",
      "            cnt++ ;\r",
      "            s+= e[i].w ;\r",
      "            if (cnt == n-1) break ;\r",
      "        }\r",
      "    }\r",
      "    return s ;\r",
      "}\r",
      ""
    ],
    "description": "minimum spanning tree krushkal algorithm"
  },
  "Dijstkra": {
    "prefix": "dijstkra",
    "body": [
      "/* --------------- Dijstkra -------------*/\r",
      "\r",
      "#define infinity 1<<30\r",
      "vector <int> g[10000] , cost[10000] ;\r",
      "\r",
      "// cin >> u >> v >> w ;\r",
      "// g[u].push_back(v) ;\r",
      "// g[v].push_back(u) ;\r",
      "// cost[u].push_back(w) ;\r",
      "// cost[v].push_back(w) ;\r",
      "\r",
      "struct node\r",
      "{\r",
      "    int u , cost ;\r",
      "    node(int _u , int _cost)\r",
      "    {\r",
      "        u = _u ;\r",
      "        cost = _cost ;\r",
      "    }\r",
      "\r",
      "    bool operator < (const node &p) const{\r",
      "        return cost > p.cost ;\r",
      "    }\r",
      "};\r",
      "\r",
      "void dijstkra(int n , vector <int> g[] , vector <int> cost[] , int source)\r",
      "{\r",
      "    int distance[n+1] ;\r",
      "    for (int i = 1 ; i<=n ; i++) distance[i] = infinity ;\r",
      "\r",
      "    priority_queue <node> q ;\r",
      "    q.push(node(source , 0)) ;\r",
      "\r",
      "    while (!q.empty())\r",
      "    {\r",
      "        node top = q.top() ;\r",
      "        q.pop() ;\r",
      "\r",
      "        int u = top.u ;\r",
      "\r",
      "        for (int i = 0 ; i<g[u].size() ; i++){\r",
      "            int v = g[u][i] ;\r",
      "\r",
      "            if (distance[u] + cost[u][i] < distance[v]){\r",
      "                distance[v] = distance[u] + cost[u][i] ;\r",
      "                q.push(node(v , distance[v])) ;\r",
      "            }\r",
      "\r",
      "        }\r",
      "    }\r",
      "}\r",
      "/* --------------- Dijstkra END -------------*/\r",
      ""
    ],
    "description": "Dijstkra"
  },
  "isPrime": {
    "prefix": "isPrime",
    "body": [
      "bool isPrime(int n)\r",
      "{\r",
      "    // Corner cases\r",
      "    if (n <= 1)\r",
      "        return false;\r",
      "    if (n <= 3)\r",
      "        return true;\r",
      "  \r",
      "    // This is checked so that we can skip\r",
      "    // middle five numbers in below loop\r",
      "    if (n % 2 == 0 || n % 3 == 0)\r",
      "        return false;\r",
      "  \r",
      "    for (int i = 5; i * i <= n; i = i + 6)\r",
      "        if (n % i == 0 || n % (i + 2) == 0)\r",
      "            return false;\r",
      "  \r",
      "    return true;\r",
      "}"
    ],
    "description": "check if it is a prime number"
  },
  "KMP Algorithm for Pattern Searching": {
    "prefix": "KMP",
    "body": [
      "// string txt = \"ABABDABACDABABCABAB\";\r",
      "// string pat = \"ABABCABAB\" ;\r",
      "\r",
      "void computeLPSArray(string pat , vector<int> & lps)\r",
      "{\r",
      "    int len = 0, i = 1 ;\r",
      "    lps[0] = 0 ;\r",
      "\r",
      "    while (i<pat.size()){\r",
      "        if (pat[i] == pat[len]){\r",
      "            len++ ;\r",
      "            lps[i++] = len ;\r",
      "        }\r",
      "        else {\r",
      "            if (len != 0) len = lps[len-1] ;\r",
      "            else lps[i++] = 0 ;\r",
      "        }\r",
      "    }\r",
      "}\r",
      "\r",
      "void KMPSearch(string pat , string txt)\r",
      "{\r",
      "    int M = pat.size() ;\r",
      "    int N = txt.size() ;\r",
      "\r",
      "    vector <int> lps(M) ;\r",
      "    computeLPSArray(pat , lps) ;\r",
      "\r",
      "    int i = 0 , j = 0 ;\r",
      "    while (i<N){\r",
      "        if (pat[j] == txt[i]) i++ , j++ ;\r",
      "\r",
      "        if (j == M){\r",
      "            // cout << \"Found Pattern at index \" << i-j << endl ;\r",
      "            j = lps[j-1] ; \r",
      "        }\r",
      "\r",
      "        else if ( i<N && pat[j] != txt[i] ){\r",
      "            if (j != 0) j = lps[j-1] ;\r",
      "            else i = i+1 ;\r",
      "        }\r",
      "    \r",
      "    }\r",
      "}"
    ],
    "description": "KMP Algorithm for Pattern Searching"
  },
  "Hashing": {
    "prefix": "hashing",
    "body": [
      "template <class T> inline T bigmod(T p,T e,T M){\r",
      "    ll ret = 1;\r",
      "    for(; e > 0; e >>= 1){\r",
      "        if(e & 1) ret = (ret * p) % M;\r",
      "        p = (p * p) % M;\r",
      "    } return (T)ret;\r",
      "}\r",
      "template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\r",
      "\r",
      "\r",
      "const ll MOD = 1e9+7 ;\r",
      "const int N = 1e6+100 ;\r",
      "const int B = 29 ;\r",
      "\r",
      "\r",
      "int _hash[N] , inv[N] ;\r",
      "\r",
      "inline int range(int l , int r)\r",
      "{\r",
      "    int ret = (_hash[r + 1] - _hash[l]) * 1ll * inv[l] % MOD;\r",
      "    if (ret < 0)\r",
      "        ret += MOD;\r",
      "    return ret;\r",
      "}\r",
      "\r",
      "void __HASH(string t , string p)\r",
      "{\r",
      "    inv[0] = 1, inv[1] = modinverse((ll)B, MOD);\r",
      "    for (int i = 2; i < N; ++i) inv[i] = inv[i - 1] * 1LL * inv[1] % MOD;\r",
      "    \r",
      "    int n = t.size();\r",
      "    int power = 1;\r",
      "    for (int i = 0; i < n; ++i)\r",
      "    {\r",
      "        _hash[i + 1] = (_hash[i] + power * 1ll * (t[i] - 'a' + 1)) % MOD;\r",
      "        power = power * 1ll * B % MOD;\r",
      "    }\r",
      "\r",
      "    int m = p.size();\r",
      "    int pattern_hash = 0;\r",
      "    power = 1;\r",
      "    for (int i = 0; i < m; ++i)\r",
      "    {\r",
      "        pattern_hash = (pattern_hash + power * 1ll * (p[i] - 'a' + 1)) % MOD;\r",
      "        power = power * 1ll * B % MOD;\r",
      "    }\r",
      "    for (int i = 0; i + m - 1 < n; ++i)\r",
      "    {\r",
      "        if (range(i, i + m - 1) == pattern_hash)\r",
      "        {\r",
      "            // printf(\"Match found starting at position %d.\\n\", i);\r",
      "        }\r",
      "    }\r",
      "}"
    ],
    "description": "Hashing"
  },
  "forward HASH and Reverse Hash": {
    "prefix": "hash struct",
    "body": [
      "template <class T> inline T bigmod(T p,T e,T M){\r",
      "    ll ret = 1;\r",
      "    for(; e > 0; e >>= 1){\r",
      "        if(e & 1) ret = (ret * p) % M;\r",
      "        p = (p * p) % M;\r",
      "    } return (T)ret;\r",
      "}\r",
      "template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\r",
      "\r",
      "struct HASHING{\r",
      "    ll MOD ;\r",
      "    int N ,B ;\r",
      "    vector <int> hash , inv ;\r",
      "    // vector <int> revHash ;\r",
      "    int n ;\r",
      "\r",
      "    HASHING(int _N , int _B , ll _M){\r",
      "        N = _N ;\r",
      "        B = _B ;\r",
      "        MOD = _M ;\r",
      "        hash.resize(N) ;\r",
      "        inv.resize(N) ;\r",
      "        // revHash.resize(N) ;\r",
      "\r",
      "        inv[0] = 1, inv[1] = modinverse((ll)B, MOD);\r",
      "        for (int i = 2; i < N; ++i) inv[i] = inv[i - 1] * 1LL * inv[1] % MOD;\r",
      "    }\r",
      "\r",
      "    // inline int invRange(int lll , int rrr)\r",
      "    // {\r",
      "    //     int l = n-1-rrr ;\r",
      "    //     int r = n-1-lll ;\r",
      "    //     int ret = (revHash[r + 1] - revHash[l]) * 1ll * inv[l] % MOD;\r",
      "    //     if (ret < 0) ret += MOD;\r",
      "    //     return ret;\r",
      "    // }\r",
      "\r",
      "    inline int range(int l , int r)\r",
      "    {\r",
      "        int ret = (hash[r + 1] - hash[l]) * 1ll * inv[l] % MOD;\r",
      "        if (ret < 0) ret += MOD;\r",
      "        return ret;\r",
      "    }\r",
      "\r",
      "    void gen(string &t)\r",
      "    {\r",
      "        n = t.size();\r",
      "        int power = 1;\r",
      "\r",
      "        for (int i = 0; i < n; ++i)\r",
      "        {\r",
      "            hash[i + 1] = (hash[i] + power * 1ll * (t[i] - 'a' + 1)) % MOD;\r",
      "            // revHash[i + 1] = (revHash[i] + power * 1ll * (t[n-1-i] - 'a' + 1)) % MOD;\r",
      "            power = power * 1ll * B % MOD;\r",
      "        }\r",
      "    }\r",
      "\r",
      "}*h1 ,*h2;"
    ],
    "description": "forward HASH and Reverse Hash"
  },
  "Double Hashing": {
    "prefix": "Hash Double",
    "body": [
      "const ll MMOD1 = 1000000007 ;\r",
      "const ll MMOD2 = 1000000009 ;\r",
      "const int BB1 = 29 ;\r",
      "const int BB2 = 31 ;\r",
      "\r",
      "// inv1[0] = 1, inv1[1] = modinverse((ll)BB1, MMOD1);\r",
      "// inv2[0] = 1, inv2[1] = modinverse((ll)BB2, MMOD2);\r",
      "\r",
      "// power1[0] = 1;\r",
      "// power2[0] = 1;\r",
      "// power1[1] = BB1 %MMOD1;\r",
      "// power2[1] = BB2 %MMOD2;\r",
      "\r",
      "// for (int i = 2; i < N; ++i){\r",
      "//     inv1[i] = inv1[i - 1] * 1LL * inv1[1] % MMOD1;\r",
      "//     inv2[i] = inv2[i - 1] * 1LL * inv2[1] % MMOD2;\r",
      "//     power1[i] = power1[i-1] * 1ll * BB1 % MMOD1;\r",
      "//     power2[i] = power2[i-1] * 1ll * BB2 % MMOD2;\r",
      "// } \r",
      "\r",
      "template <class T> inline T bigmod(T p,T e,T M){\r",
      "    ll ret = 1;\r",
      "    for(; e > 0; e >>= 1){\r",
      "        if(e & 1) ret = (ret * p) % M;\r",
      "        p = (p * p) % M;\r",
      "    } return (T)ret;\r",
      "}\r",
      "template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\r",
      "\r",
      "int inv1[N], inv2[N] ,power1[N] , power2[N] ;\r",
      "struct HASHING{\r",
      "    ll MOD1, MOD2 ;\r",
      "    int B1 , B2, has1[N] , has2[N] ;\r",
      "    int n ;\r",
      " \r",
      "    HASHING( int _B1 , ll _M1 , int _B2 , ll _M2 ){\r",
      "        B1 = _B1 ;\r",
      "        B2 = _B2 ;\r",
      "        MOD1 = _M1 ;\r",
      "        MOD2 = _M2 ;\r",
      "    }\r",
      "\r",
      "    inline PII range(int l , int r)\r",
      "    {\r",
      "        int ret1 = (has1[r + 1] - has1[l]) * 1ll * inv1[l] % MOD1;\r",
      "        int ret2 = (has2[r + 1] - has2[l]) * 1ll * inv2[l] % MOD2;\r",
      "        if (ret1 < 0) ret1 += MOD1;\r",
      "        if (ret2 < 0) ret2 += MOD2;\r",
      "        return {ret1,ret2};\r",
      "    }\r",
      " \r",
      "    void gen(string &t)\r",
      "    {\r",
      "        n = t.size();\r",
      "\r",
      " \r",
      "        for (int i = 0; i < n; ++i){\r",
      "            has1[i + 1] = (has1[i] + power1[i] * 1ll * (t[i] - 'a' + 1)) % MOD1;\r",
      "            has2[i + 1] = (has2[i] + power2[i] * 1ll * (t[i] - 'a' + 1)) % MOD2;\r",
      "        }\r",
      "    }\r",
      " \r",
      "}*h1 ,*h2;"
    ],
    "description": "Double Hashing"
  },
  "Z Algorithm": {
    "prefix": "ZALGORITHM",
    "body": [
      "void getZarr(string str, vector <int> & Z)\r",
      "{\r",
      "\tint n = str.length();\r",
      "\tint L, R, k;\r",
      "\r",
      "\tL = R = 0;\r",
      "\tfor (int i = 1; i < n; ++i)\r",
      "\t{\r",
      "\t\tif (i > R){\r",
      "\t\t\tL = R = i;\r",
      "\t\t\twhile (R<n && str[R-L] == str[R])   R++;\r",
      "\t\t\tZ[i] = R-L;\r",
      "\t\t\tR--;\r",
      "\t\t}\r",
      "\t\telse{\r",
      "\t\t\tk = i-L;\r",
      "\t\t\tif (Z[k] < R-i+1) Z[i] = Z[k];\r",
      "\t\t\telse{\r",
      "\t\t\t\tL = i;\r",
      "\t\t\t\twhile (R<n && str[R-L] == str[R])   R++;\r",
      "\t\t\t\tZ[i] = R-L;\r",
      "\t\t\t\tR--;\r",
      "\t\t\t}\r",
      "\t\t}\r",
      "\t}\r",
      "}\r",
      "\r",
      "// string text = \"GEEKS FOR GEEKS\";\r",
      "// string pattern = \"GEEK\";\r",
      "\r",
      "void search(string text, string pattern)\r",
      "{\r",
      "\tstring concat = pattern + \"\\$\" + text;\r",
      "\tint l = concat.length();\r",
      "\r",
      "\tvector<int> Z(l);\r",
      "\tgetZarr(concat, Z);\r",
      "\r",
      "\tfor (int i = 0; i < l; ++i)\r",
      "\t{\r",
      "\t\tif (Z[i] == pattern.length())\r",
      "\t\t\tcout << \"Pattern found at index \"\r",
      "\t\t\t\t<< i - pattern.length() -1 << endl;\r",
      "\t}\r",
      "}\r",
      ""
    ],
    "description": "Z Algorithm"
  },
  "Random Template": {
    "prefix": "Random Template",
    "body": [
      "unsigned seed1 = std::chrono::system_clock::now().time_since_epoch().count();\r",
      "default_random_engine gen(seed1); //gen(time(NULL));\r",
      "\r",
      "int randd(int a , int b)\r",
      "{\r",
      "    std::uniform_int_distribution<int> dis(a, b );\r",
      "    return dis(gen) ;\r",
      "}\r",
      "\r",
      "long long randd(long long a , long long b)\r",
      "{\r",
      "    std::uniform_int_distribution<long long> dis(a, b );\r",
      "    return dis(gen) ;\r",
      "}\r",
      "\r",
      "\r",
      "long double randd(long double a , long double b)\r",
      "{\r",
      "    std::uniform_real_distribution<long double> dis(a, b );\r",
      "    return dis(gen) ;\r",
      "}"
    ],
    "description": "Random Template"
  },
  "primeFactSieve": {
    "prefix": "primeFactSieve",
    "body": [
      "int fact[N] ;\r",
      "//primeFactor(1e7) ;\r",
      "void primeFactor(int n){\r",
      "    for (int i = 2 ; i<=n ; i+=2) fact[i] = 2 ;\r",
      "    for (int i = 3 ; i<=n ; i+=2){\r",
      "        if (fact[i] == 0){\r",
      "            for (int j = i ; j<=n ; j+=i){\r",
      "                if (fact[j] == 0) fact[j] = i ;\r",
      "            }\r",
      "        }\r",
      "    }\r",
      "}"
    ],
    "description": "primeFactSieve"
  },
  "SparseTable": {
    "prefix": "SparseTable",
    "body": [
      "template <typename T, class F = function<T(const T &, const T &)>>\r",
      "class SparseTable\r",
      "{\r",
      "public:\r",
      "    int n;\r",
      "    vector<vector<T>> mat;\r",
      "    F func;\r",
      "\r",
      "    SparseTable(const vector<T> &a, const F &f) : func(f)\r",
      "    {\r",
      "        n = static_cast<int>(a.size());\r",
      "        int max_log = 32 - __builtin_clz(n);\r",
      "        mat.resize(max_log);\r",
      "        mat[0] = a;\r",
      "        for (int j = 1; j < max_log; j++)\r",
      "        {\r",
      "            mat[j].resize(n - (1 << j) + 1);\r",
      "            for (int i = 0; i <= n - (1 << j); i++)\r",
      "            {\r",
      "                mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\r",
      "            }\r",
      "        }\r",
      "    }\r",
      "\r",
      "    T get(int from, int to) const\r",
      "    {\r",
      "        assert(0 <= from && from <= to && to <= n - 1);\r",
      "        int lg = 32 - __builtin_clz(to - from + 1) - 1;\r",
      "        return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\r",
      "    }\r",
      "};\r",
      "// vector <ll> b(n-1) ;\r",
      "// SparseTable<long long> st(b, [&](long long i, long long j) { return __gcd(i, j); });",
      "// st.get(i, j)"
    ],
    "description": "SparceTable"
  },
  "articulation point": {
    "prefix": "Articulation point",
    "body": [
      "template <typename T>\r",
      "struct ArticulationPoint\r",
      "{\r",
      "T n; // size\r",
      "T timer;\r",
      "vector<T> disc, low;\r",
      "vector<bool> vis, isArticulation;\r",
      "ArticulationPoint(T sz, vector<T> g[], T source)\r",
      "{\r",
      "n = sz;\r",
      "disc.resize(sz + 5);\r",
      "low.resize(sz + 5);\r",
      "vis.resize(sz + 5, 0);\r",
      "isArticulation.resize(sz + 5, 0);\r",
      "timer = 1;\r",
      "dfs(source, -1, g);\r",
      "}\r",
      "\r",
      "void dfs(T u, T par, vector<T> g[])\r",
      "{\r",
      "vis[u] = 1;\r",
      "disc[u] = low[u] = ++timer;\r",
      "T children = 0;\r",
      "for (auto v : g[u])\r",
      "{\r",
      "if (v == par)\r",
      "continue;\r",
      "if (vis[v])\r",
      "low[u] = min(low[u], disc[v]);\r",
      "else\r",
      "{\r",
      "dfs(v, u, g);\r",
      "low[u] = min(low[u], low[v]);\r",
      "if (low[v] >= disc[u] && par != -1)\r",
      "isArticulation[u] = 1;\r",
      "children++;\r",
      "}\r",
      "}\r",
      "if (par == -1 && children > 1)\r",
      "isArticulation[u] = 1;\r",
      "}\r",
      "\r",
      "bool get_point(T node)\r",
      "{\r",
      "return isArticulation[node];\r",
      "}\r",
      "};"
    ],
    "description": "articulation point"
  },
  "segment tree": {
    "prefix": "segment tree",
    "body": [
      "struct dt",
      "{",
      "    int val;",
      "    dt() {}",
      "    dt(int _val)",
      "    {",
      "        val = _val;",
      "    }",
      "};",
      "",
      "template <",
      "    typename T,",
      "    class F = function<T(const T &, const T &)>,",
      "    class F2 = function<void(const int &, const int &, const int &, vector<T> &)>>",
      "class SegmentTree",
      "{",
      "public:",
      "    int n;",
      "    F func;",
      "    F2 func2;",
      "    vector<T> arr;",
      "",
      "    SegmentTree(int _n, const F &f, const F2 &f2) : func(f), n(_n), func2(f2)",
      "    {",
      "        dt tmp(0);",
      "        arr.assign(n * 4, tmp);",
      "    }",
      "",
      "    void init(int node, int b, int e)",
      "    {",
      "        if (b == e)",
      "        {",
      "            // cin >> arr[node];",
      "            return;",
      "        }",
      "        int left = node * 2;",
      "        int right = node * 2 + 1;",
      "        int mid = (b + e) / 2;",
      "",
      "        init(left, b, mid);",
      "        init(right, mid + 1, e);",
      "",
      "        arr[node] = func(arr[left], arr[right]);",
      "    }",
      "",
      "    void updt(int node, int b, int e, int i, int j, ll newvalue)",
      "    {",
      "        if (i > e || j < b)",
      "            return;",
      "        if (b >= i && e <= j)",
      "        {",
      "            arr[node].val += newvalue;",
      "            return;",
      "        }",
      "        int left = node * 2;",
      "        int right = node * 2 + 1;",
      "        int mid = (b + e) / 2;",
      "",
      "        // func2(node, b, e, arr); // for lazy",
      "",
      "        updt(left, b, mid, i, j, newvalue);",
      "        updt(right, mid + 1, e, i, j, newvalue);",
      "",
      "        arr[node] = func(arr[left], arr[right]);",
      "    }",
      "",
      "    T qry(int node, int b, int e, int i, int j)",
      "    {",
      "        if (i > e || j < b)",
      "            return dt(0); // Must check here if this value is ok or not",
      "",
      "        if (b >= i and e <= j)",
      "            return arr[node];",
      "",
      "        int left = node * 2;",
      "        int right = node * 2 + 1;",
      "        int mid = (b + e) / 2;",
      "",
      "        // func2(node, b, e, arr); // for lazy",
      "",
      "        auto p1 = qry(left, b, mid, i, j);",
      "        auto p2 = qry(right, mid + 1, e, i, j);",
      "",
      "        return func(p1, p2);",
      "    }",
      "",
      "    void update(int i, int j, ll newValue)",
      "    {",
      "        updt(1, 1, n, i, j, newValue);",
      "    }",
      "    T query(int i, int j)",
      "    {",
      "        return qry(1, 1, n, i, j);",
      "    }",
      "};",
      "// int sz = 1e5;",
      "// SegmentTree<dt> seg(",
      "//     sz,",
      "//     [&](auto a, auto b)",
      "//     {",
      "//         dt newDt = dt(a.val+b.val) ;",
      "//         return newDt; },",
      "",
      "//     [&](int node, int b, int e, auto &arr)",
      "//     {",
      "//         // int left = node * 2;",
      "//         // int right = node * 2 + 1;",
      "//         // int mid = (b + e) / 2;",
      "",
      "//         // Do lazy",
      "//         return;",
      "//     });"
    ],
    "description": "segment tree"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "class dsu\r",
      "{\r",
      "public:\r",
      "    vector<int> parent;\r",
      "    int n;\r",
      "\r",
      "    dsu(int _n) : n(_n)\r",
      "    {\r",
      "        parent.resize(n);\r",
      "        iota(parent.begin(), parent.end(), 0);\r",
      "    }\r",
      "\r",
      "    inline int get(int x)\r",
      "    {\r",
      "        return (x == parent[x] ? x : (parent[x] = get(parent[x])));\r",
      "    }\r",
      "\r",
      "    inline bool unite(int x, int y)\r",
      "    {\r",
      "        x = get(x);\r",
      "        y = get(y);\r",
      "        if (x != y)\r",
      "        {\r",
      "            parent[x] = y;\r",
      "            return true;\r",
      "        }\r",
      "        return false;\r",
      "    }\r",
      "};"
    ],
    "description": "dsu"
  },
  "dsu_with_rollback": {
    "prefix": "dsu_with_rollback",
    "body": [
      "class dsu_with_rollback",
      "{",
      "public:",
      "    vector<int> parent;",
      "    int n;",
      "    int cc;",
      "    vector<unordered_map<int, int>> history;",
      "",
      "    dsu_with_rollback(int _n) : n(_n)",
      "    {",
      "        cc = n;",
      "        parent.resize(n);",
      "        iota(parent.begin(), parent.end(), 0);",
      "    }",
      "",
      "    inline int get(int x)",
      "    {",
      "        if (x == parent[x])",
      "            return x;",
      "        auto fin = get(parent[x]);",
      "        if (fin != parent[x])",
      "        {",
      "            if (!history.empty())",
      "            {",
      "                auto it = history.back().find(x);",
      "                if (it == history.back().end())",
      "                {",
      "                    history.back()[x] = parent[x];",
      "                }",
      "            }",
      "        }",
      "        return parent[x] = fin;",
      "    }",
      "",
      "    inline bool unite(int x, int y)",
      "    {",
      "        x = get(x);",
      "        y = get(y);",
      "        if (x != y)",
      "        {",
      "",
      "            if (!history.empty())",
      "            {",
      "                auto it = history.back().find(x);",
      "                if (it == history.back().end())",
      "                {",
      "                    history.back()[x] = parent[x];",
      "                }",
      "            }",
      "            cc--;",
      "",
      "            parent[x] = y;",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "",
      "    void saveDsu()",
      "    {",
      "        unordered_map<int, int> temp;",
      "        history.push_back(temp);",
      "    }",
      "",
      "    void rollBack()",
      "    {",
      "        if (!history.empty())",
      "        {",
      "            for (auto [x, y] : history.back())",
      "            {",
      "                parent[x] = y;",
      "                if (x == y)",
      "                    cc++;",
      "            }",
      "            history.pop_back();",
      "        }",
      "    }",
      "};",
      "",
      "/*",
      "    dsu_with_rollback dt(15);",
      "    dt.get(5);",
      "    dt.unite(1, 2);",
      "    dt.saveDsu(); // create a point for roll back",
      "    dt.rollBack(); // roll back to previous save point",
      "*/"
    ],
    "description": ""
  },
  "cp start": {
    "prefix": "cp start",
    "body": [
      "/*\r",
      "    Moontasir Mahmood \r",
      "    Information and Communication Engineering \r",
      "    University of Rajshahi \r",
      "    https://github.com/Munmud \r",
      "    moontasir042@gmail.com \r",
      " */\r",
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      "#define setinf(ar) memset(ar, 126, sizeof ar)\r",
      "#define MEM(a, b) memset(a, (b), sizeof(a))\r",
      "#define MAX(a, b) ((a) > (b) ? (a) : (b))\r",
      "#define MIN(a, b) ((a) < (b) ? (a) : (b))\r",
      "#define S(X) ((X) * (X))\r",
      "#define SZ(V) (int)V.size()\r",
      "#define FORN(i, n) for (int i = 0; i < n; i++)\r",
      "#define FORAB(i, a, b) for (int i = a; i <= b; i++)\r",
      "#define FORBA(i, b, a) for (int i = b; i >= a; i--)\r",
      "#define ALL(V) V.begin(), V.end()\r",
      "#define ALLR(V) V.rbegin(), V.rend()\r",
      "#define IN(A, B, C) ((B) <= (A) && (A) <= (C))\r",
      "#define AIN(A, B, C) assert(IN(A, B, C))\r",
      "\r",
      "#define nl \"\\n\"\r",
      "\r",
      "#define ll long long int\r",
      "#define xx first\r",
      "#define yy second\r",
      "#define pb push_back\r",
      "#define PI acos(-1.0)\r",
      "\r",
      "#define PII pair<int, int>\r",
      "#define PLL pair<long long int, long long int>\r",
      "#define VI vector<int>\r",
      "#define VL vector<long long int>\r",
      "#define VPII vector<PII>\r",
      "#define VPLL vector<PLL>\r",
      "\r",
      "#define BOUNDARY(i, j, r, c) ((i >= 0 && i < r) && (j >= 0 && j < c))\r",
      "#define max3(x, y, z) MAX(MAX(x, y), MAX(y, z))\r",
      "\r",
      "#define front_zero(n) __builtin_clzll(n)\r",
      "#define back_zero(n) __builtin_ctzll(n)\r",
      "#define total_one(n) __builtin_popcountll(n)\r",
      "\r",
      "template <typename T>\r",
      "int SIZE(T(&t))\r",
      "{\r",
      "    return t.size();\r",
      "}\r",
      "template <typename T, size_t N>\r",
      "int SIZE(T (&t)[N])\r",
      "{\r",
      "    return N;\r",
      "}\r",
      "string to_string(char t)\r",
      "{\r",
      "    return \"'\" + string({t}) + \"'\";\r",
      "}\r",
      "string to_string(bool t)\r",
      "{\r",
      "    return t ? \"true\" : \"false\";\r",
      "}\r",
      "string to_string(const string &t, int x1 = 0, int x2 = 1e9)\r",
      "{\r",
      "    string ret = \"\";\r",
      "    for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i)\r",
      "    {\r",
      "        ret += t[i];\r",
      "    }\r",
      "    return '\"' + ret + '\"';\r",
      "}\r",
      "string to_string(const char *t)\r",
      "{\r",
      "    string ret(t);\r",
      "    return to_string(ret);\r",
      "}\r",
      "template <size_t N>\r",
      "string to_string(const bitset<N> &t, int x1 = 0, int x2 = 1e9)\r",
      "{\r",
      "    string ret = \"\";\r",
      "    for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i)\r",
      "    {\r",
      "        ret += t[i] + '0';\r",
      "    }\r",
      "    return to_string(ret);\r",
      "}\r",
      "template <typename T, typename... Coords>\r",
      "string to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\r",
      "template <typename T, typename S>\r",
      "string to_string(const pair<T, S> &t)\r",
      "{\r",
      "    return \"(\" + to_string(t.first) + \", \" + to_string(t.second) + \")\";\r",
      "}\r",
      "template <typename T, typename... Coords>\r",
      "string to_string(const T(&t), int x1, int x2, Coords... C)\r",
      "{\r",
      "    string ret = \"[\";\r",
      "    x1 = min(x1, SIZE(t));\r",
      "    auto e = begin(t);\r",
      "    advance(e, x1);\r",
      "    for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i)\r",
      "    {\r",
      "        ret += to_string(*e, C...) + (i != _i ? \", \" : \"\");\r",
      "        e = next(e);\r",
      "    }\r",
      "    return ret + \"]\";\r",
      "}\r",
      "template <int Index, typename... Ts>\r",
      "struct print_tuple\r",
      "{\r",
      "    string operator()(const tuple<Ts...> &t)\r",
      "    {\r",
      "        string ret = print_tuple<Index - 1, Ts...>{}(t);\r",
      "        ret += (Index ? \", \" : \"\");\r",
      "        return ret + to_string(get<Index>(t));\r",
      "    }\r",
      "};\r",
      "template <typename... Ts>\r",
      "struct print_tuple<0, Ts...>\r",
      "{\r",
      "    string operator()(const tuple<Ts...> &t)\r",
      "    {\r",
      "        return to_string(get<0>(t));\r",
      "    }\r",
      "};\r",
      "template <typename... Ts>\r",
      "string to_string(const tuple<Ts...> &t)\r",
      "{\r",
      "    const auto Size = tuple_size<tuple<Ts...>>::value;\r",
      "    return print_tuple<Size - 1, Ts...>{}(t);\r",
      "}\r",
      "void dbgr() { ; }\r",
      "template <typename Heads, typename... Tails>\r",
      "void dbgr(Heads H, Tails... T)\r",
      "{\r",
      "    cerr << to_string(H) << \" | \";\r",
      "    dbgr(T...);\r",
      "}\r",
      "void dbgs() { ; }\r",
      "template <typename Heads, typename... Tails>\r",
      "void dbgs(Heads H, Tails... T)\r",
      "{\r",
      "    cerr << H << \" \";\r",
      "    dbgs(T...);\r",
      "}\r",
      "// #undef LOCAL\r",
      "#ifdef LOCAL\r",
      "#define dbgv(...) cerr << to_string(__VA_ARGS__) << endl;\r",
      "#define dbga(...)                         \\\r",
      "    cerr << \"[\" << #__VA_ARGS__ << \"]: \"; \\\r",
      "    dbgv(__VA_ARGS__);\r",
      "#define dbgr(...)      \\\r",
      "    dbgr(__VA_ARGS__); \\\r",
      "    cerr << endl;\r",
      "#define dbg(...)                          \\\r",
      "    cerr << \"[\" << #__VA_ARGS__ << \"]: \"; \\\r",
      "    dbgr(__VA_ARGS__);\r",
      "#else\r",
      "#define dbgv(...) 42\r",
      "#define dbga(...) 42\r",
      "#define dbgr(...) 42\r",
      "#define dbg(...) 42\r",
      "#endif\r",
      "\r",
      "const ll MOD = 1e9 + 7;\r",
      "const int N = 1e6 + 100;\r",
      "\r",
      "void _main_main()\r",
      "{\r",
      "    ll n, m;$0\r",
      "}\r",
      "\r",
      "int main()\r",
      "{\r",
      "    ios::sync_with_stdio(0);\r",
      "    cin.tie(0);\r",
      "    cout.tie(0);\r",
      "\r",
      "    int testCase = 1;\r",
      "    //cin >> testCase ;\r",
      "    for (int i = 0; i < testCase; i++)\r",
      "    {\r",
      "        _main_main();\r",
      "    }\r",
      "}"
    ],
    "description": "cp start"
  },
  "inversion count": {
    "prefix": "inversion count",
    "body": [
      "int _mergeSort(int arr[], int temp[], int left, int right);",
      "int merge(int arr[], int temp[], int left, int mid,",
      "          int right);",
      "",
      "int mergeSort(int arr[], int array_size)",
      "{",
      "    int temp[array_size];",
      "    return _mergeSort(arr, temp, 0, array_size - 1);",
      "}",
      "",
      "int _mergeSort(int arr[], int temp[], int left, int right)",
      "{",
      "    int mid, inv_count = 0;",
      "    if (right > left)",
      "    {",
      "",
      "        mid = (right + left) / 2;",
      "",
      "        inv_count += _mergeSort(arr, temp, left, mid);",
      "        inv_count += _mergeSort(arr, temp, mid + 1, right);",
      "",
      "        inv_count += merge(arr, temp, left, mid + 1, right);",
      "    }",
      "    return inv_count;",
      "}",
      "",
      "int merge(int arr[], int temp[], int left, int mid,",
      "          int right)",
      "{",
      "    int i, j, k;",
      "    int inv_count = 0;",
      "",
      "    i = left;",
      "    j = mid;",
      "    k = left;",
      "    while ((i <= mid - 1) && (j <= right))",
      "    {",
      "        if (arr[i] <= arr[j])",
      "        {",
      "            temp[k++] = arr[i++];",
      "        }",
      "        else",
      "        {",
      "            temp[k++] = arr[j++];",
      "",
      "            inv_count = inv_count + (mid - i);",
      "        }",
      "    }",
      "",
      "    while (i <= mid - 1)",
      "        temp[k++] = arr[i++];",
      "",
      "    while (j <= right)",
      "        temp[k++] = arr[j++];",
      "",
      "    for (i = left; i <= right; i++)",
      "        arr[i] = temp[i];",
      "    return inv_count;",
      "}",
      "",
      "// int arr[] = { 1, 20, 6, 4, 5 };",
      "// int n = sizeof(arr) / sizeof(arr[0]);",
      "// int ans = mergeSort(arr, n);",
      "",
      ""
    ],
    "description": "inversion count"
  },
  "BIT": {
    "prefix": "BIT",
    "body": [
      "template <typename T>",
      "class BIT",
      "{",
      "    vector<T> bit;",
      "    int n;",
      "",
      "public:",
      "    BIT(int n)",
      "    {",
      "        this->n = n;",
      "        bit.assign(n, 0);",
      "    }",
      "",
      "    BIT(const vector<T> &a) : BIT(a.size())",
      "    {",
      "        for (size_t i = 0; i < a.size(); i++)",
      "            add(i, a[i]);",
      "    }",
      "",
      "    void add(int index, T value)",
      "    {",
      "        assert(index >= 0 && index < n);",
      "        for (; index < n; index = index | (index + 1))",
      "            bit[index] += value;",
      "    }",
      "",
      "    T sum(int r)",
      "    {",
      "        assert(r >= 0);",
      "        T ret = 0;",
      "        for (; r >= 0; r = (r & (r + 1)) - 1)",
      "            ret += bit[r];",
      "        return ret;",
      "    }",
      "",
      "    T range(int l, int r)",
      "    {",
      "        assert(l >= 0 && r < n && l <= r);",
      "        return sum(r) - sum(l - 1);",
      "    }",
      "};",
      "/*",
      "    Binary Index Tree or Fenwick Tree User Manual",
      "    index -> from 0 to n-1",
      "",
      "    declare:",
      "    BIT<int> dt(10);",
      "*/"
    ],
    "description": ""
  },
  "debug template": {
    "prefix": "debug template",
    "body": [
      "template <typename T>\r",
      "int SIZE(T(&t))\r",
      "{\r",
      "    return t.size();\r",
      "}\r",
      "template <typename T, size_t N>\r",
      "int SIZE(T (&t)[N])\r",
      "{\r",
      "    return N;\r",
      "}\r",
      "string to_string(char t)\r",
      "{\r",
      "    return \"'\" + string({t}) + \"'\";\r",
      "}\r",
      "string to_string(bool t)\r",
      "{\r",
      "    return t ? \"true\" : \"false\";\r",
      "}\r",
      "string to_string(const string &t, int x1 = 0, int x2 = 1e9)\r",
      "{\r",
      "    string ret = \"\";\r",
      "    for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i)\r",
      "    {\r",
      "        ret += t[i];\r",
      "    }\r",
      "    return '\"' + ret + '\"';\r",
      "}\r",
      "string to_string(const char *t)\r",
      "{\r",
      "    string ret(t);\r",
      "    return to_string(ret);\r",
      "}\r",
      "template <size_t N>\r",
      "string to_string(const bitset<N> &t, int x1 = 0, int x2 = 1e9)\r",
      "{\r",
      "    string ret = \"\";\r",
      "    for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i)\r",
      "    {\r",
      "        ret += t[i] + '0';\r",
      "    }\r",
      "    return to_string(ret);\r",
      "}\r",
      "template <typename T, typename... Coords>\r",
      "string to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\r",
      "template <typename T, typename S>\r",
      "string to_string(const pair<T, S> &t)\r",
      "{\r",
      "    return \"(\" + to_string(t.first) + \", \" + to_string(t.second) + \")\";\r",
      "}\r",
      "template <typename T, typename... Coords>\r",
      "string to_string(const T(&t), int x1, int x2, Coords... C)\r",
      "{\r",
      "    string ret = \"[\";\r",
      "    x1 = min(x1, SIZE(t));\r",
      "    auto e = begin(t);\r",
      "    advance(e, x1);\r",
      "    for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i)\r",
      "    {\r",
      "        ret += to_string(*e, C...) + (i != _i ? \", \" : \"\");\r",
      "        e = next(e);\r",
      "    }\r",
      "    return ret + \"]\";\r",
      "}\r",
      "template <int Index, typename... Ts>\r",
      "struct print_tuple\r",
      "{\r",
      "    string operator()(const tuple<Ts...> &t)\r",
      "    {\r",
      "        string ret = print_tuple<Index - 1, Ts...>{}(t);\r",
      "        ret += (Index ? \", \" : \"\");\r",
      "        return ret + to_string(get<Index>(t));\r",
      "    }\r",
      "};\r",
      "template <typename... Ts>\r",
      "struct print_tuple<0, Ts...>\r",
      "{\r",
      "    string operator()(const tuple<Ts...> &t)\r",
      "    {\r",
      "        return to_string(get<0>(t));\r",
      "    }\r",
      "};\r",
      "template <typename... Ts>\r",
      "string to_string(const tuple<Ts...> &t)\r",
      "{\r",
      "    const auto Size = tuple_size<tuple<Ts...>>::value;\r",
      "    return print_tuple<Size - 1, Ts...>{}(t);\r",
      "}\r",
      "void dbgr() { ; }\r",
      "template <typename Heads, typename... Tails>\r",
      "void dbgr(Heads H, Tails... T)\r",
      "{\r",
      "    cerr << to_string(H) << \" | \";\r",
      "    dbgr(T...);\r",
      "}\r",
      "void dbgs() { ; }\r",
      "template <typename Heads, typename... Tails>\r",
      "void dbgs(Heads H, Tails... T)\r",
      "{\r",
      "    cerr << H << \" \";\r",
      "    dbgs(T...);\r",
      "}\r",
      "// #undef LOCAL\r",
      "#ifdef LOCAL\r",
      "#define dbgv(...) cerr << to_string(__VA_ARGS__) << endl;\r",
      "#define dbga(...)                         \\\r",
      "    cerr << \"[\" << #__VA_ARGS__ << \"]: \"; \\\r",
      "    dbgv(__VA_ARGS__);\r",
      "#define dbgr(...)      \\\r",
      "    dbgr(__VA_ARGS__); \\\r",
      "    cerr << endl;\r",
      "#define dbg(...)                          \\\r",
      "    cerr << \"[\" << #__VA_ARGS__ << \"]: \"; \\\r",
      "    dbgr(__VA_ARGS__);\r",
      "#else\r",
      "#define dbgv(...) 42\r",
      "#define dbga(...) 42\r",
      "#define dbgr(...) 42\r",
      "#define dbg(...) 42\r",
      "#endif"
    ],
    "description": "debug template"
  },
  "mosAlgo": {
    "prefix": "mosAlgo",
    "body": [
      "void rmv(int idx)",
      "{",
      "    // TODO: remove value at idx",
      "}",
      "void add(int idx)",
      "{",
      "    // TODO: add value at idx",
      "}",
      "",
      "int get_answer()",
      "{",
      "    // TODO: extract the answer",
      "}",
      "",
      "int blk_size;",
      "",
      "struct Query",
      "{",
      "    int l, r, idx;",
      "    Query() {}",
      "    Query(int _l, int _r, int _idx)",
      "    {",
      "        l = _l;",
      "        r = _r;",
      "        idx = _idx;",
      "    }",
      "    bool operator<(Query other) const",
      "    {",
      "        return make_pair(l / blk_size, r) <",
      "               make_pair(other.l / blk_size, other.r);",
      "    }",
      "};",
      "",
      "vector<int> mo_s_algorithm(vector<Query> & queries)",
      "{",
      "    vector<int> res(queries.size());",
      "    sort(queries.begin(), queries.end());",
      "",
      "    // TODO: initialize data structure",
      "",
      "    int cur_l = 0;",
      "    int cur_r = -1;",
      "    // range [cur_l, cur_r]",
      "    for (Query q : queries)",
      "    {",
      "        while (cur_l > q.l)",
      "        {",
      "            cur_l--;",
      "            add(cur_l);",
      "        }",
      "        while (cur_r < q.r)",
      "        {",
      "            cur_r++;",
      "            add(cur_r);",
      "        }",
      "        while (cur_l < q.l)",
      "        {",
      "            rmv(cur_l);",
      "            cur_l++;",
      "        }",
      "        while (cur_r > q.r)",
      "        {",
      "            rmv(cur_r);",
      "            cur_r--;",
      "        }",
      "        res[q.idx] = get_answer();",
      "    }",
      "    return res;",
      "}",
      "// TODO : ADD BLOCK SIZE",
      "// blk_size = (int)(sqrt(n)) + 1;"
    ],
    "description": "mosAlgo"
  },
  "inputFile": {
    "prefix": "inputFile",
    "body": [
      "// #define INPUTFILE\r",
      "#ifdef INPUTFILE\r",
      "freopen(\"input.txt\", \"r\", stdin);\r",
      "freopen(\"output.txt\", \"w\", stdout);\r",
      "#else\r",
      "ios::sync_with_stdio(0);\r",
      "cin.tie(0);\r",
      "cout.tie(0);\r",
      "#endif\r"
    ],
    "description": "inputFile"
  },

  "LCA": {
    "prefix": "LCA",
    "body": [
      "const int N = 1e5 + 10;\r",
      "\r",
      "int LOG;\r",
      "vector<int> g[N];\r",
      "vector<int> tree_hight;\r",
      "\r",
      "int timer;\r",
      "vector<int> tin, tout;\r",
      "vector<vector<int>> up;\r",
      "\r",
      "void dfs(int u, int p, int h = 0)\r",
      "{\r",
      "\ttin[u] = ++timer;\r",
      "\tup[u][0] = p;\r",
      "\ttree_hight[u] = h;\r",
      "\r",
      "\tfor (int v : g[u])\r",
      "\t\tif (v != p)\r",
      "\t\t\tdfs(v, u, h + 1);\r",
      "\r",
      "\ttout[u] = ++timer;\r",
      "}\r",
      "\r",
      "bool is_ancestor(int u, int v)\r",
      "{\r",
      "\treturn tin[u] <= tin[v] && tout[u] >= tout[v];\r",
      "}\r",
      "\r",
      "int lca(int u, int v)\r",
      "{\r",
      "\tif (is_ancestor(u, v))\r",
      "\t\treturn u;\r",
      "\tif (is_ancestor(v, u))\r",
      "\t\treturn v;\r",
      "\tfor (int i = LOG; i >= 0; --i)\r",
      "\t{\r",
      "\t\tif (!is_ancestor(up[u][i], v))\r",
      "\t\t\tu = up[u][i];\r",
      "\t}\r",
      "\treturn up[u][0];\r",
      "}\r",
      "\r",
      "int distance_between_two_node(int u, int v)\r",
      "{\r",
      "\tint res = lca(u, v);\r",
      "\treturn tree_hight[u] + tree_hight[v] - tree_hight[res] - tree_hight[res];\r",
      "}\r",
      "\r",
      "void preprocess(int n, int root)\r",
      "{\r",
      "\ttin.resize(n);\r",
      "\ttout.resize(n);\r",
      "\ttree_hight.resize(n);\r",
      "\ttimer = 0;\r",
      "\r",
      "\tLOG = ceil(log2(n));\r",
      "\tup.assign(n, vector<int>(LOG + 1));\r",
      "\tdfs(root, root);\r",
      "\r",
      "\tfor (int i = 1; i <= LOG; i++)\r",
      "\t{\r",
      "\t\tfor (int u = 0; u < n; u++)\r",
      "\t\t{\r",
      "\t\t\tup[u][i] = up[up[u][i - 1]][i - 1];\r",
      "\t\t}\r",
      "\t}\r",
      "}\r",
      ""
    ],
    "description": "LCA"
  },
  "Miller Rabin Primality Test": {
    "prefix": "Miller Rabin Primality Test",
    "body": [
      "template <class T>\r",
      "inline T bigmod(T p, T e, T M)\r",
      "{\r",
      "    ll ret = 1;\r",
      "    for (; e > 0; e >>= 1)\r",
      "    {\r",
      "        if (e & 1)\r",
      "            ret = (ret * p) % M;\r",
      "        p = (p * p) % M;\r",
      "    }\r",
      "    return (T)ret;\r",
      "}\r",
      "\r",
      "bool check_composite(ll n, ll a, ll d, int s)\r",
      "{\r",
      "    ll x = bigmod(a, d, n);\r",
      "    if (x == 1 || x == n - 1)\r",
      "        return false;\r",
      "\r",
      "    for (int r = 1; r <= s; r++)\r",
      "    {\r",
      "        x = (int)x * x % n;\r",
      "        if (x == n - 1)\r",
      "            return false;\r",
      "    }\r",
      "    return true;\r",
      "}\r",
      "\r",
      "bool MillerRabin(ll n)\r",
      "{\r",
      "    if (n < 2)\r",
      "    {\r",
      "        return false;\r",
      "    }\r",
      "\r",
      "    int r = 0;\r",
      "    ll d = n - 1;\r",
      "    while ((d & 1) == 0)\r",
      "    {\r",
      "        d >>= 1;\r",
      "        r++;\r",
      "    }\r",
      "\r",
      "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37})\r",
      "    {\r",
      "        if (n == a)\r",
      "            return true;\r",
      "        if (check_composite(n, a, d, r))\r",
      "        {\r",
      "            return false;\r",
      "        }\r",
      "    }\r",
      "    return true;\r",
      "}"
    ],
    "description": "Miller Rabin Primality Test"
  },
  "leetcode": {
    "prefix": "leetcode",
    "body": [
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      "#define setinf(ar) memset(ar, 126, sizeof ar)\r",
      "#define MEM(a, b) memset(a, (b), sizeof(a))\r",
      "#define MAX(a, b) ((a) > (b) ? (a) : (b))\r",
      "#define MIN(a, b) ((a) < (b) ? (a) : (b))\r",
      "#define S(X) ((X) * (X))\r",
      "#define SZ(V) (int)V.size()\r",
      "#define FORN(i, n) for (int i = 0; i < n; i++)\r",
      "#define FORAB(i, a, b) for (int i = a; i <= b; i++)\r",
      "#define FORBA(i, b, a) for (int i = b; i >= a; i--)\r",
      "#define ALL(V) V.begin(), V.end()\r",
      "#define ALLR(V) V.rbegin(), V.rend()\r",
      "#define IN(A, B, C) ((B) <= (A) && (A) <= (C))\r",
      "#define AIN(A, B, C) assert(IN(A, B, C))\r",
      "\r",
      "#define nl \"\\n\"\r",
      "\r",
      "#define ll long long int\r",
      "#define xx first\r",
      "#define yy second\r",
      "#define pb push_back\r",
      "#define PI acos(-1.0)\r",
      "\r",
      "#define PII pair<int, int>\r",
      "#define PLL pair<long long int, long long int>\r",
      "#define VI vector<int>\r",
      "#define VL vector<long long int>\r",
      "#define VPII vector<PII>\r",
      "#define VPLL vector<PLL>\r",
      "\r",
      "#define BOUNDARY(i, j, r, c) ((i >= 0 && i < r) && (j >= 0 && j < c))\r",
      "#define max3(x, y, z) MAX(MAX(x, y), MAX(y, z))\r",
      "\r",
      "#define front_zero(n) __builtin_clzll(n)\r",
      "#define back_zero(n) __builtin_ctzll(n)\r",
      "#define total_one(n) __builtin_popcountll(n)\r",
      "\r",
      "const ll MOD = 1e9 + 7;\r",
      "const int N = 1e6 + 100;\r",
      ""
    ],
    "description": "leetcode"
  },
  "ModValueTemplate": {
    "prefix": "modValueTemplate",
    "body": [
      "const unsigned int MOD = 998244353;\r",
      "template<unsigned int mod = MOD> struct mint { // 1000000007  1000000009\r",
      "\tunsigned int x;\r",
      " \r",
      "\tmint() : x(0) {}\r",
      "\tmint(ll _x) {\r",
      "\t\t_x %= mod;\r",
      "\t\tif (_x < 0) _x += mod;\r",
      "\t\tx = _x;\r",
      "\t}\r",
      " \r",
      "\tmint& operator += (const mint &a) {\r",
      "\t\tx += a.x;\r",
      "\t\tif (x >= mod) x -= mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint& operator -= (const mint &a) {\r",
      "\t\tx += mod - a.x;\r",
      "\t\tif (x >= mod) x -= mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint& operator *= (const mint &a) {\r",
      "\t\tx = (ull)x * a.x % mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint pow(ll pw) const {\r",
      "\t\tmint res = 1;\r",
      "\t\tmint cur = *this;\r",
      "\t\twhile(pw) {\r",
      "\t\t\tif (pw & 1) res *= cur;\r",
      "\t\t\tcur *= cur;\r",
      "\t\t\tpw >>= 1;\r",
      "\t\t}\r",
      "\t\treturn res;\r",
      "\t}\r",
      "\tmint inv() const {\r",
      "\t\tassert(x != 0);\r",
      "\t\tunsigned int t = x;\r",
      "\t\tunsigned int res = 1;\r",
      "\t\twhile(t != 1) {\r",
      "\t\t\tunsigned int z = mod / t;\r",
      "\t\t\tres = (ull)res * (mod - z) % mod;\r",
      "\t\t\tt = mod - t * z;\r",
      "\t\t}\r",
      "\t\treturn res;\r",
      "\t}\r",
      "\tmint& operator /= (const mint &a) {\r",
      "\t\treturn *this *= a.inv();\r",
      "\t}\r",
      "\tmint operator + (const mint &a) const {\r",
      "\t\treturn mint(*this) += a;\r",
      "\t}\r",
      "\tmint operator - (const mint &a) const {\r",
      "\t\treturn mint(*this) -= a;\r",
      "\t}\r",
      "\tmint operator * (const mint &a) const {\r",
      "\t\treturn mint(*this) *= a;\r",
      "\t}\r",
      "\tmint operator / (const mint &a) const {\r",
      "\t\treturn mint(*this) /= a;\r",
      "\t}\r",
      " \r",
      "\tbool sqrt(mint &res) const {\r",
      "\t\tif (mod == 2 || x == 0) {\r",
      "\t\t\tres = *this;\r",
      "\t\t\treturn true;\r",
      "\t\t}\r",
      "\t\tif (pow((mod - 1) / 2) != 1) return false;\r",
      "\t\tif (mod % 4 == 3) {\r",
      "\t\t\tres = pow((mod + 1) / 4);\r",
      "\t\t\treturn true;\r",
      "\t\t}\r",
      "\t\tint pw = (mod - 1) / 2;\r",
      "\t\tint K = 30;\r",
      "\t\twhile((1 << K) > pw) K--;\r",
      "\t\twhile(true) {\r",
      "\t\t\tmint t = myRand(mod);\r",
      "\t\t\tmint a = 0, b = 0, c = 1;\r",
      "\t\t\tfor (int k = K; k >= 0; k--) {\r",
      "\t\t\t\ta = b * b;\r",
      "\t\t\t\tb = b * c * 2;\r",
      "\t\t\t\tc = c * c + a * *this;\r",
      "\t\t\t\tif (((pw >> k) & 1) == 0) continue;\r",
      "\t\t\t\ta = b;\r",
      "\t\t\t\tb = b * t + c;\r",
      "\t\t\t\tc = c * t + a * *this;\r",
      "\t\t\t}\r",
      "\t\t\tif (b == 0) continue;\r",
      "\t\t\tc -= 1;\r",
      "\t\t\tc *= mint() - b.inv();\r",
      "\t\t\tif (c * c == *this) {\r",
      "\t\t\t\tres = c;\r",
      "\t\t\t\treturn true;\r",
      "\t\t\t}\r",
      "\t\t}\r",
      "\t\tassert(false);\r",
      "\t}\r",
      " \r",
      "\tbool operator == (const mint &a) const {\r",
      "\t\treturn x == a.x;\r",
      "\t}\r",
      "\tbool operator != (const mint &a) const {\r",
      "\t\treturn x != a.x;\r",
      "\t}\r",
      "\tbool operator < (const mint &a) const {\r",
      "\t\treturn x < a.x;\r",
      "\t}\r",
      "};\r",
      "template<unsigned int mod = MOD> struct Powers {\r",
      "\tusing Mint = mint<mod>;\r",
      "\tvector<Mint> p, pi;\r",
      " \r",
      "\tPowers() : p(), pi() {}\r",
      "\tPowers(int n, Mint x) {\r",
      "\t\tn += 10;\r",
      "\t\tif (x == 0) {\r",
      "\t\t\tp = vector<Mint>(n);\r",
      "\t\t\tp[0] = 1;\r",
      "\t\t} else {\r",
      "\t\t\tp = vector<Mint>(n);\r",
      "\t\t\tpi = vector<Mint>(n);\r",
      "\t\t\tp[0] = pi[0] = 1;\r",
      "\t\t\tMint xi = x.inv();\r",
      "\t\t\tfor (int i = 1; i < n; i++) {\r",
      "\t\t\t\tp[i] = p[i - 1] * x;\r",
      "\t\t\t\tpi[i] = pi[i - 1] * xi;\r",
      "\t\t\t}\r",
      "\t\t}\r",
      "\t}\r",
      " \r",
      "\tMint pow(int n) {\r",
      "\t\tif (n >= 0)\r",
      "\t\t\treturn p[n];\r",
      "\t\telse\r",
      "\t\t\treturn pi[-n];\r",
      "\t}\r",
      "};\r",
      "template<unsigned int mod = MOD> struct Factorials {\r",
      "\tusing Mint = mint<mod>;\r",
      "\tvector<Mint> f, fi;\r",
      " \r",
      "\tFactorials() : f(), fi() {}\r",
      "\tFactorials(int n) {\r",
      "\t\tn += 10;\r",
      "\t\tf = vector<Mint>(n);\r",
      "\t\tfi = vector<Mint>(n);\r",
      "\t\tf[0] = 1;\r",
      "\t\tfor (int i = 1; i < n; i++)\r",
      "\t\t\tf[i] = f[i - 1] * i;\r",
      "\t\tfi[n - 1] = f[n - 1].inv();\r",
      "\t\tfor (int i = n - 1; i > 0; i--)\r",
      "\t\t\tfi[i - 1] = fi[i] * i;\r",
      "\t}\r",
      " \r",
      "\tMint C(int n, int k) {\r",
      "\t\tif (k < 0 || k > n) return 0;\r",
      "\t\treturn f[n] * fi[k] * fi[n - k];\r",
      "\t}\r",
      "};\r",
      "template<unsigned int mod = MOD> struct Inverses {\r",
      "\tusing Mint = mint<mod>;\r",
      "\tvector<Mint> ii;\r",
      " \r",
      "\tInverses() : ii() {}\r",
      "\tInverses(int n) {\r",
      "\t\tn += 10;\r",
      "\t\tii = vector<Mint>(n);\r",
      "\t\tii[1] = 1;\r",
      "\t\tfor (int x = 2; x < n; x++)\r",
      "\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\r",
      "\t}\r",
      " \r",
      "\tMint inv(Mint x) {\r",
      "\t\tassert(x != 0);\r",
      "\t\tunsigned int t = x.x;\r",
      "\t\tunsigned int res = 1;\r",
      "\t\twhile(t >= (int)ii.size()) {\r",
      "\t\t\tunsigned int z = mod / t;\r",
      "\t\t\tres = (ull)res * (mod - z) % mod;\r",
      "\t\t\tt = mod - t * z;\r",
      "\t\t}\r",
      "\t\treturn ii[t] * res;\r",
      "\t}\r",
      "};\r",
      "using Mint = mint<>;\r",
      "// Factorials F(N);F.C(3,2) ;\r",
      "// Mint ans = 0;"
    ],
    "description": "ModValueTemplate"
  },
  "modulo auto template": {
    "prefix": "modulo auto Template",
    "body": [
      "using ull = unsigned long long;\r",
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\r",
      "ll myRand(ll B){return (ull)rng() % B;}\r",
      "const unsigned int MOD = 998244353;\r",
      "template<unsigned int mod = MOD> struct mint { // 1000000007  1000000009\r",
      "\tunsigned int x;\r",
      " \r",
      "\tmint() : x(0) {}\r",
      "\tmint(ll _x) {\r",
      "\t\t_x %= mod;\r",
      "\t\tif (_x < 0) _x += mod;\r",
      "\t\tx = _x;\r",
      "\t}\r",
      " \r",
      "\tmint& operator += (const mint &a) {\r",
      "\t\tx += a.x;\r",
      "\t\tif (x >= mod) x -= mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint& operator -= (const mint &a) {\r",
      "\t\tx += mod - a.x;\r",
      "\t\tif (x >= mod) x -= mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint& operator *= (const mint &a) {\r",
      "\t\tx = (ull)x * a.x % mod;\r",
      "\t\treturn *this;\r",
      "\t}\r",
      "\tmint pow(ll pw) const {\r",
      "\t\tmint res = 1;\r",
      "\t\tmint cur = *this;\r",
      "\t\twhile(pw) {\r",
      "\t\t\tif (pw & 1) res *= cur;\r",
      "\t\t\tcur *= cur;\r",
      "\t\t\tpw >>= 1;\r",
      "\t\t}\r",
      "\t\treturn res;\r",
      "\t}\r",
      "\tmint inv() const {\r",
      "\t\tassert(x != 0);\r",
      "\t\tunsigned int t = x;\r",
      "\t\tunsigned int res = 1;\r",
      "\t\twhile(t != 1) {\r",
      "\t\t\tunsigned int z = mod / t;\r",
      "\t\t\tres = (ull)res * (mod - z) % mod;\r",
      "\t\t\tt = mod - t * z;\r",
      "\t\t}\r",
      "\t\treturn res;\r",
      "\t}\r",
      "\tmint& operator /= (const mint &a) {\r",
      "\t\treturn *this *= a.inv();\r",
      "\t}\r",
      "\tmint operator + (const mint &a) const {\r",
      "\t\treturn mint(*this) += a;\r",
      "\t}\r",
      "\tmint operator - (const mint &a) const {\r",
      "\t\treturn mint(*this) -= a;\r",
      "\t}\r",
      "\tmint operator * (const mint &a) const {\r",
      "\t\treturn mint(*this) *= a;\r",
      "\t}\r",
      "\tmint operator / (const mint &a) const {\r",
      "\t\treturn mint(*this) /= a;\r",
      "\t}\r",
      " \r",
      "\tbool sqrt(mint &res) const {\r",
      "\t\tif (mod == 2 || x == 0) {\r",
      "\t\t\tres = *this;\r",
      "\t\t\treturn true;\r",
      "\t\t}\r",
      "\t\tif (pow((mod - 1) / 2) != 1) return false;\r",
      "\t\tif (mod % 4 == 3) {\r",
      "\t\t\tres = pow((mod + 1) / 4);\r",
      "\t\t\treturn true;\r",
      "\t\t}\r",
      "\t\tint pw = (mod - 1) / 2;\r",
      "\t\tint K = 30;\r",
      "\t\twhile((1 << K) > pw) K--;\r",
      "\t\twhile(true) {\r",
      "\t\t\tmint t = myRand(mod);\r",
      "\t\t\tmint a = 0, b = 0, c = 1;\r",
      "\t\t\tfor (int k = K; k >= 0; k--) {\r",
      "\t\t\t\ta = b * b;\r",
      "\t\t\t\tb = b * c * 2;\r",
      "\t\t\t\tc = c * c + a * *this;\r",
      "\t\t\t\tif (((pw >> k) & 1) == 0) continue;\r",
      "\t\t\t\ta = b;\r",
      "\t\t\t\tb = b * t + c;\r",
      "\t\t\t\tc = c * t + a * *this;\r",
      "\t\t\t}\r",
      "\t\t\tif (b == 0) continue;\r",
      "\t\t\tc -= 1;\r",
      "\t\t\tc *= mint() - b.inv();\r",
      "\t\t\tif (c * c == *this) {\r",
      "\t\t\t\tres = c;\r",
      "\t\t\t\treturn true;\r",
      "\t\t\t}\r",
      "\t\t}\r",
      "\t\tassert(false);\r",
      "\t}\r",
      " \r",
      "\tbool operator == (const mint &a) const {\r",
      "\t\treturn x == a.x;\r",
      "\t}\r",
      "\tbool operator != (const mint &a) const {\r",
      "\t\treturn x != a.x;\r",
      "\t}\r",
      "\tbool operator < (const mint &a) const {\r",
      "\t\treturn x < a.x;\r",
      "\t}\r",
      "};\r",
      "template<unsigned int mod = MOD> struct Powers {\r",
      "\tusing Mint = mint<mod>;\r",
      "\tvector<Mint> p, pi;\r",
      " \r",
      "\tPowers() : p(), pi() {}\r",
      "\tPowers(int n, Mint x) {\r",
      "\t\tn += 10;\r",
      "\t\tif (x == 0) {\r",
      "\t\t\tp = vector<Mint>(n);\r",
      "\t\t\tp[0] = 1;\r",
      "\t\t} else {\r",
      "\t\t\tp = vector<Mint>(n);\r",
      "\t\t\tpi = vector<Mint>(n);\r",
      "\t\t\tp[0] = pi[0] = 1;\r",
      "\t\t\tMint xi = x.inv();\r",
      "\t\t\tfor (int i = 1; i < n; i++) {\r",
      "\t\t\t\tp[i] = p[i - 1] * x;\r",
      "\t\t\t\tpi[i] = pi[i - 1] * xi;\r",
      "\t\t\t}\r",
      "\t\t}\r",
      "\t}\r",
      " \r",
      "\tMint pow(int n) {\r",
      "\t\tif (n >= 0)\r",
      "\t\t\treturn p[n];\r",
      "\t\telse\r",
      "\t\t\treturn pi[-n];\r",
      "\t}\r",
      "};\r",
      "template<unsigned int mod = MOD> struct Factorials {\r",
      "\tusing Mint = mint<mod>;\r",
      "\tvector<Mint> f, fi;\r",
      " \r",
      "\tFactorials() : f(), fi() {}\r",
      "\tFactorials(int n) {\r",
      "\t\tn += 10;\r",
      "\t\tf = vector<Mint>(n);\r",
      "\t\tfi = vector<Mint>(n);\r",
      "\t\tf[0] = 1;\r",
      "\t\tfor (int i = 1; i < n; i++)\r",
      "\t\t\tf[i] = f[i - 1] * i;\r",
      "\t\tfi[n - 1] = f[n - 1].inv();\r",
      "\t\tfor (int i = n - 1; i > 0; i--)\r",
      "\t\t\tfi[i - 1] = fi[i] * i;\r",
      "\t}\r",
      " \r",
      "\tMint nCr(int n, int k) {\r",
      "\t\tif (k < 0 || k > n) return 0;\r",
      "\t\treturn f[n] * fi[k] * fi[n - k];\r",
      "\t}\r",
      "};\r",
      "using Mint = mint<>;\r",
      "// Factorials F(N);F.C(3,2) ;\r",
      "// Mint ans = 0;"
    ],
    "description": "modulo auto template"
  },
  "centroid tree": {
    "prefix": "centroid tree",
    "body": [
      "// 0 based index\r",
      "VI g[N];\r",
      "vector<bool> done;\r",
      "VI sz;\r",
      "int cur_sz;\r",
      "// VI cenPar;\r",
      "VI cenG[N];\r",
      "\r",
      "void set_sz(int u, int pre) {\r",
      "    cur_sz++;\r",
      "    sz[u] = 1;\r",
      "    for (auto v : g[u]) {\r",
      "        if (v == pre || done[v]) continue;\r",
      "        set_sz(v, u);\r",
      "        sz[u] += sz[v];\r",
      "    }\r",
      "}\r",
      "int get_centroid(int u, int pre) {\r",
      "    for (auto v : g[u]) {\r",
      "        if (v == pre || done[v]) continue;\r",
      "        if (sz[v] > cur_sz / 2) return get_centroid(v, u);\r",
      "    }\r",
      "    return u;\r",
      "}\r",
      "\r",
      "void decompose(int u, int pre) {\r",
      "    cur_sz = 0;\r",
      "    set_sz(u, pre);\r",
      "    int centroid = get_centroid(u, pre);\r",
      "    // cenPar[centroid] = pre;\r",
      "    if (pre != -1)\r",
      "        cenG[pre].pb(centroid);\r",
      "    done[centroid] = 1;\r",
      "    for (auto v : g[centroid]) {\r",
      "        if (v == pre || done[v]) continue;\r",
      "        decompose(v, centroid);\r",
      "    }\r",
      "}\r",
      "\r",
      "void Centroid_Tree_PreProcess(int n)\r",
      "{\r",
      "    FORN(i, n) cenG[i].clear();\r",
      "    sz.resize(n);\r",
      "    // cenPar.resize(n);\r",
      "    done.assign(n, 0);\r",
      "    decompose(0, -1);\r",
      "}"
    ],
    "description": "centroid tree"
  }
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
}
